<script>
    import { beforeUpdate, createEventDispatcher, onDestroy, onMount, tick } from 'svelte';
    import { offset, flip, shift } from '@floating-ui/dom';
    import { createFloatingActions } from 'svelte-floating-ui';

    const dispatch = createEventDispatcher();

    import _filter from './filter';
    import _getItems from './get-items';

    import ChevronIcon from './ChevronIcon.svelte';
    import ClearIcon from './ClearIcon.svelte';
    import LoadingIcon from './LoadingIcon.svelte';

    export let justValue = null; // read-only

    export let filter = _filter;
    export let getItems = _getItems;

    export let id = null;
    export let container = undefined;
    export let input = undefined;
    export let multiple = false;
    export let multiFullItemClearable = false;
    export let disabled = false;
    export let focused = false;
    export let value = null;
    export let filterText = '';
    export let placeholder = 'Please select';
    export let placeholderAlwaysShow = false;
    export let items = null;
    export let label = 'label';
    export let itemFilter = (label, filterText) => `${label}`.toLowerCase().includes(filterText.toLowerCase());
    export let groupBy = undefined;
    export let groupFilter = (groups) => groups;
    export let groupHeaderSelectable = false;
    export let itemId = 'value';
    export let loadOptions = undefined;
    export let containerStyles = '';

    export let createGroupHeaderItem = (groupValue, item) => {
        return {
            value: groupValue,
            label: groupValue,
        };
    };

    export const getFilteredItems = () => {
        return filteredItems;
    };

    export let searchable = true;
    export let inputStyles = '';
    export let clearable = true;
    export let loading = false;
    export let listOpen = false;

    let timeout;
    export let debounce = (fn, wait = 1) => {
        clearTimeout(timeout);
        timeout = setTimeout(fn, wait);
    };

    export let debounceWait = 300;
    export let hideEmptyState = false;
    export let inputAttributes = {};
    export let listAutoWidth = true;
    export let showChevron = false;
    export let listOffset = 5;

    export { containerClasses as class };

    let containerClasses = '';
    let activeValue;
    let prev_value;
    let prev_filterText;
    let prev_multiple;
    let hoverItemIndex = 0;

    function setValue() {
        if (typeof value === 'string') {
            let item = items.find((item) => item[itemId] === value);
            value = item || {
                [itemId]: value,
                label: value,
            };
        } else if (multiple && Array.isArray(value) && value.length > 0) {
            value = value.map((item) => (typeof item === 'string' ? { value: item, label: item } : item));
        }
    }

    let _inputAttributes;
    function assignInputAttributes() {
        _inputAttributes = Object.assign(
            {
                autocapitalize: 'none',
                autocomplete: 'off',
                autocorrect: 'off',
                spellcheck: false,
                tabindex: 0,
                type: 'text',
                'aria-autocomplete': 'list',
            },
            inputAttributes
        );

        if (id) {
            _inputAttributes['id'] = id;
        }

        if (!searchable) {
            _inputAttributes['readonly'] = true;
        }
    }

    function convertStringItemsToObjects(_items) {
        return _items.map((item, index) => {
            return {
                index,
                value: item,
                label: `${item}`,
            };
        });
    }

    function filterGroupedItems(_items) {
        const groupValues = [];
        const groups = {};

        _items.forEach((item) => {
            const groupValue = groupBy(item);

            if (!groupValues.includes(groupValue)) {
                groupValues.push(groupValue);
                groups[groupValue] = [];

                if (groupValue) {
                    groups[groupValue].push(
                        Object.assign(createGroupHeaderItem(groupValue, item), {
                            id: groupValue,
                            groupHeader: true,
                            selectable: groupHeaderSelectable,
                        })
                    );
                }
            }

            groups[groupValue].push(Object.assign({ groupItem: !!groupValue }, item));
        });

        const sortedGroupedItems = [];

        groupFilter(groupValues).forEach((groupValue) => {
            if (groups[groupValue]) sortedGroupedItems.push(...groups[groupValue]);
        });

        return sortedGroupedItems;
    }

    function dispatchSelectedItem() {
        if (multiple) {
            if (JSON.stringify(value) !== JSON.stringify(prev_value)) {
                if (checkValueForDuplicates()) {
                    dispatch('change', value);
                }
            }
            return;
        }

        if (!prev_value || JSON.stringify(value[itemId]) !== JSON.stringify(prev_value[itemId])) {
            dispatch('change', value);
        }
    }

    function setupMulti() {
        if (value) {
            if (Array.isArray(value)) {
                value = [...value];
            } else {
                value = [value];
            }
        }
    }

    function setupSingle() {
        if (value) value = null;
    }

    $: if ((items, value)) setValue();
    $: if (inputAttributes || !searchable) assignInputAttributes();
    $: if (multiple) setupMulti();
    $: if (prev_multiple && !multiple) setupSingle();
    $: if (multiple && value && value.length > 1) checkValueForDuplicates();
    $: if (value) dispatchSelectedItem();
    $: if (!value && multiple && prev_value) dispatch('change', value);
    $: if (!focused && input) listOpen = false;
    $: if (!listOpen) filterText = '';
    $: if (filterText !== prev_filterText) setupFilterText();

    function setupFilterText() {
        if (filterText.length === 0) return;

        focused = true;
        listOpen = true;

        if (loadOptions) {
            debounce(async function () {
                loading = true;
                let res = await getItems({
                    dispatch,
                    loadOptions,
                    convertStringItemsToObjects,
                    filterText,
                });

                if (res) {
                    loading = res.loading;
                    focused = res.focused;
                    listOpen = res.listOpen;
                    items = groupBy ? filterGroupedItems(res.filteredItems) : res.filteredItems;
                } else {
                    loading = false;
                    focused = true;
                    listOpen = true;
                }
            }, debounceWait);
        } else {
            listOpen = true;

            if (multiple) {
                activeValue = undefined;
            }
        }
    }

    $: hasValue = multiple ? value && value.length > 0 : value;
    $: hideSelectedItem = hasValue && filterText.length > 0;
    $: showClear = hasValue && clearable && !disabled && !loading;
    $: placeholderText = placeholderAlwaysShow && multiple ? placeholder : value ? '' : placeholder;
    $: showMultiSelect = multiple && value && value.length > 0;
    $: ariaSelection = value ? handleAriaSelection(multiple) : '';
    $: ariaContext = handleAriaContent({ filteredItems, hoverItemIndex, focused, listOpen });
    $: updateValueDisplay(items);
    $: justValue = computeJustValue(multiple, value, itemId);
    $: if (!multiple && prev_value && !value) dispatch('change', value);

    $: filteredItems = filter({
        loadOptions,
        filterText,
        items,
        multiple,
        value,
        itemId,
        groupBy,
        label,
        itemFilter,
        convertStringItemsToObjects,
        filterGroupedItems,
    });

    $: if (filteredItems) setHoverIndex(0);

    beforeUpdate(async () => {
        prev_value = value;
        prev_filterText = filterText;
        prev_multiple = multiple;
    });

    function computeJustValue() {
        if (multiple) return value ? value.map((item) => item[itemId]) : null;
        return value ? value[itemId] : value;
    }

    function checkValueForDuplicates() {
        let noDuplicates = true;
        if (value) {
            const ids = [];
            const uniqueValues = [];

            value.forEach((val) => {
                if (!ids.includes(val[itemId])) {
                    ids.push(val[itemId]);
                    uniqueValues.push(val);
                } else {
                    noDuplicates = false;
                }
            });

            if (!noDuplicates) value = uniqueValues;
        }
        return noDuplicates;
    }

    function findItem(selection) {
        let matchTo = selection ? selection[itemId] : value[itemId];
        return items.find((item) => item[itemId] === matchTo);
    }

    function updateValueDisplay(items) {
        if (!items || items.length === 0 || items.some((item) => typeof item !== 'object')) return;
        if (!value || (multiple ? value.some((selection) => !selection || !selection[itemId]) : !value[itemId])) return;

        if (Array.isArray(value)) {
            value = value.map((selection) => findItem(selection) || selection);
        } else {
            value = findItem() || value;
        }
    }

    async function handleMultiItemClear(i) {
        const itemToRemove = value[i];

        if (value.length === 1) {
            value = undefined;
        } else {
            value = value.filter((item) => {
                return item !== itemToRemove;
            });
        }

        dispatch('clear', itemToRemove);
    }

    function handleKeyDown(e) {
        if (!focused) return;
        e.stopPropagation();

        switch (e.key) {
            case 'Escape':
                e.preventDefault();
                closeList();
                break;
            case 'Enter':
                e.preventDefault();

                if (listOpen) {
                    if (filteredItems.length === 0) break;
                    const hoverItem = filteredItems[hoverItemIndex];

                    if (hoverItem?.selectable === false) break;

                    if (value && !multiple && value[itemId] === hoverItem[itemId]) {
                        closeList();
                        break;
                    } else {
                        activeItemIndex = hoverItemIndex;
                        handleSelect(filteredItems[hoverItemIndex]);
                    }
                }

                break;
            case 'ArrowDown':
                e.preventDefault();

                if (listOpen) {
                    changeHoverIndex(1);
                } else {
                    setHoverIndex(0);
                    listOpen = true;
                    activeValue = undefined;
                }

                break;
            case 'ArrowUp':
                e.preventDefault();

                if (listOpen) {
                    changeHoverIndex(-1);
                } else {
                    listOpen = true;
                    activeValue = undefined;
                }

                break;
            case 'Tab':
                if (listOpen && focused) {
                    if (
                        filteredItems.length === 0 ||
                        (value && value[itemId] === filteredItems[hoverItemIndex][itemId])
                    )
                        return closeList();

                    e.preventDefault();
                    activeItemIndex = hoverItemIndex;
                    handleSelect(filteredItems[hoverItemIndex]);
                    listOpen = false;
                }

                break;
            case 'Backspace':
                if (!multiple || filterText.length > 0) return;

                if (multiple && value && value.length > 0) {
                    handleMultiItemClear(activeValue !== undefined ? activeValue : value.length - 1);
                    if (activeValue === 0 || activeValue === undefined) break;
                    activeValue = value.length > activeValue ? activeValue - 1 : undefined;
                }

                break;
            case 'ArrowLeft':
                if (!value || !multiple || filterText.length > 0) return;
                if (activeValue === undefined) {
                    activeValue = value.length - 1;
                } else if (value.length > activeValue && activeValue !== 0) {
                    activeValue -= 1;
                }
                break;
            case 'ArrowRight':
                if (!value || !multiple || filterText.length > 0 || activeValue === undefined) return;
                if (activeValue === value.length - 1) {
                    activeValue = undefined;
                } else if (activeValue < value.length - 1) {
                    activeValue += 1;
                }
                break;
        }
    }

    function handleFocus(e) {
        if (e) dispatch('focus', e);
        input.focus();
        focused = true;
    }

    function handleBlur(e) {
        if (listOpen || focused) {
            dispatch('blur', e);
            listOpen = false;
            focused = false;
            activeValue = undefined;
            input.blur();
        }
    }

    function handleClick() {
        if (disabled) return;
        setHoverIndex(0);
        listOpen = !listOpen;
        if (listOpen && !focused) handleFocus();
    }

    export function handleClear() {
        value = undefined;
        listOpen = false;
        dispatch('clear', value);
        handleFocus();
    }

    onMount(() => {
        if (listOpen) focused = true;
        if (focused && input) input.focus();
    });

    function itemSelected(selection) {
        if (selection) {
            filterText = '';
            const item = Object.assign({}, selection);

            if (!item.groupHeader || item.selectable) {
                if (multiple) {
                    value = value ? value.concat([item]) : [item];
                } else {
                    value = item;
                }

                value = value;

                setTimeout(() => {
                    listOpen = false;
                    activeValue = undefined;
                    dispatch('select', value);
                });
            }
        }
    }

    function closeList() {
        filterText = '';
        listOpen = false;
    }

    export let ariaValues = (values) => {
        return `Option ${values}, selected.`;
    };

    export let ariaListOpen = (label, count) => {
        return `You are currently focused on option ${label}. There are ${count} results available.`;
    };

    export let ariaFocused = () => {
        return `Select is focused, type to refine list, press down to open the menu.`;
    };

    function handleAriaSelection(_multiple) {
        let selected = undefined;

        if (_multiple && value.length > 0) {
            selected = value.map((v) => v[label]).join(', ');
        } else {
            selected = value[label];
        }

        return ariaValues(selected);
    }

    function handleAriaContent() {
        if (!filteredItems || filteredItems.length === 0) return '';
        let _item = filteredItems[hoverItemIndex];
        if (listOpen && _item) {
            let count = filteredItems ? filteredItems.length : 0;
            return ariaListOpen(_item[label], count);
        } else {
            return ariaFocused();
        }
    }

    let list = null;

    let isScrollingTimer;
    function handleListScroll() {
        clearTimeout(isScrollingTimer);
        isScrollingTimer = setTimeout(() => {
            isScrolling = false;
        }, 100);
    }

    function handleClickOutside(event) {
        if (container && !container.contains(event.target) && !list?.contains(event.target)) {
            handleBlur();
        }
    }

    onDestroy(() => {
        list?.remove();
    });

    export let activeItemIndex = 0;

    let isScrolling = false;

    function handleSelect(item) {
        if (item.isCreator) return;
        itemSelected(item);
    }

    function handleHover(i) {
        if (isScrolling) return;
        setHoverIndex(i);
    }

    function handleItemClick(args) {
        const { item, i } = args;
        if (item?.selectable === false) return;
        if (value && !multiple && value[itemId] === item[itemId]) return closeList();
        if (isItemSelectable(item)) {
            activeItemIndex = i;
            hoverItemIndex = i;
            handleSelect(item);
        }
    }

    /**
     * Converts a desired index in a index that is in bound with `filteredItems`.
     *
     * desiredIndex > bigger than array size -> 0
     *
     * desiredIndex < 0 -> last array index
     * @param {number} desiredIndex
     * @returns {number} A version of the desired index that is in bound
     */
    function getInBoundIndex(desiredIndex) {
        if (desiredIndex > filteredItems.length) return 0;
        if (desiredIndex < 0) return filteredItems.length - 1;
        return desiredIndex;
    }

    let scrollToHoverItem = 0;

    /**
     * Increments or decrements the `hoverItemIndex` while keeping the index in bound
     * and skipping indexes with non selectable items.
     * @param {number} increment Positive or negative integer for amount and direction in which the index should change
     * @returns {number} The first index that fulfilled the requirements and was subsequently set
     */
    function changeHoverIndex(increment) {
        // Get a in bound index with the applied change
        let newIndex = getInBoundIndex(hoverItemIndex + increment);

        // Go further in the wished direction until there is a selectable item
        while (!isItemSelectable(filteredItems[newIndex])) {
            if (increment < 0) newIndex--;
            if (increment > 0) newIndex++;
            newIndex = getInBoundIndex(newIndex);
        }

        // Set the new index
        hoverItemIndex = newIndex;
        scrollToHoverItem = newIndex;

        return newIndex;
    }

    /**
     * Set the `hoverItemIndex` while keeping the index in bound and skipping
     * indexes with non selectable items.
     * @param {number} newIndex The new desired index
     * @returns {number} The first index that fulfilled the requirements and was subsequently set
     */
    function setHoverIndex(newIndex) {
        newIndex = getInBoundIndex(newIndex);

        // Increment the index until the item is selectable
        while (!isItemSelectable(filteredItems[newIndex])) {
            newIndex++;
            newIndex = getInBoundIndex(newIndex);
        }

        hoverItemIndex = newIndex;

        return newIndex;
    }

    function isItemActive(item, value, itemId) {
        if (multiple) return;
        return value && value[itemId] === item[itemId];
    }

    function isItemFirst(itemIndex) {
        return itemIndex === 0;
    }

    function isItemSelectable(item) {
        return (item.groupHeader && item.selectable) || item.selectable || !item.hasOwnProperty('selectable');
    }

    const activeScroll = scrollAction;
    const hoverScroll = scrollAction;

    function scrollAction(node) {
        return {
            update(args) {
                if (args.scroll) node.scrollIntoView({ behavior: 'auto', block: 'nearest', inline: 'start' });
            },
        };
    }

    $: if (listOpen && container && list) setListWidth();

    function setListWidth() {
        const { width } = container.getBoundingClientRect();
        list.style.width = listAutoWidth ? width + 'px' : 'auto';
    }

    export let floatingConfig = {};
    $: setupFloat(floatingConfig);

    let _floatingConfig = {
        strategy: 'absolute',
        placement: 'bottom-start',
        middleware: [offset(listOffset), flip(), shift()],
    };

    const [floatingRef, floatingContent] = createFloatingActions(_floatingConfig);

    $: listMounted = !!list;
    function setupFloat() {
        _floatingConfig = Object.assign(_floatingConfig, floatingConfig);
    }
</script>

<svelte:window on:click={handleClickOutside} on:keydown={handleKeyDown} />

<div
    class="svelte-select {containerClasses}"
    class:multi={multiple}
    class:disabled
    class:focused
    class:list-open={listOpen}
    class:show-chevron={showChevron}
    style={containerStyles}
    on:pointerdown|preventDefault={handleClick}
    on:click|preventDefault|stopPropagation
    bind:this={container}
    use:floatingRef>
    {#if listOpen}
        <div
            use:floatingContent
            bind:this={list}
            class="svelte-select-list"
            on:scroll={handleListScroll}
            on:pointerdown|preventDefault|stopPropagation>
            {#if $$slots.list}<slot name="list" {filteredItems} />
            {:else if filteredItems.length > 0}
                {#each filteredItems as item, i}
                    <div
                        on:mouseover={() => handleHover(i)}
                        on:focus={() => handleHover(i)}
                        on:click|stopPropagation={() => handleItemClick({ item, i })}
                        class="list-item"
                        tabindex="-1">
                        <div
                            use:activeScroll={{ scroll: isItemActive(item, value, itemId), listMounted }}
                            use:hoverScroll={{ scroll: scrollToHoverItem === i, listMounted }}
                            class="item"
                            class:list-group-title={item.groupHeader}
                            class:active={isItemActive(item, value, itemId)}
                            class:first={isItemFirst(i)}
                            class:hover={hoverItemIndex === i}
                            class:group-item={item.groupItem}
                            class:not-selectable={item?.selectable === false}>
                            <slot name="item" {item} index={i}>
                                {item?.[label]}
                            </slot>
                        </div>
                    </div>
                {/each}
            {:else if !hideEmptyState}
                <slot name="empty">
                    <div class="empty">No options</div>
                </slot>
            {/if}
        </div>
    {/if}

    <span aria-live="polite" aria-atomic="false" aria-relevant="additions text" class="a11y-text">
        {#if focused}
            <span id="aria-selection">{ariaSelection}</span>
            <span id="aria-context">
                {ariaContext}
            </span>
        {/if}
    </span>

    <slot name="prepend" />

    <div class="value-container">
        {#if hasValue}
            {#if multiple}
                {#each value as item, i}
                    <div
                        class="multi-item"
                        class:active={activeValue === i}
                        class:disabled
                        on:click|preventDefault={() => (multiFullItemClearable ? handleMultiItemClear(i) : {})}>
                        <span class="multi-item-text">
                            <slot name="selection" selection={item}>
                                {item[label]}
                            </slot>
                        </span>

                        {#if !disabled && !multiFullItemClearable && ClearIcon}
                            <div
                                class="multi-item-clear"
                                on:pointerdown|preventDefault|stopPropagation
                                on:click={() => handleMultiItemClear(i)}>
                                <slot name="multi-clear-icon">
                                    <ClearIcon />
                                </slot>
                            </div>
                        {/if}
                    </div>
                {/each}
            {:else}
                <div class="selected-item" class:hide-selected-item={hideSelectedItem}>
                    <slot name="selection" selection={value}>
                        {value[label]}
                    </slot>
                </div>
            {/if}
        {/if}

        <input
            on:keydown={handleKeyDown}
            on:blur={handleBlur}
            on:focus={handleFocus}
            readOnly={!searchable}
            {..._inputAttributes}
            bind:this={input}
            bind:value={filterText}
            placeholder={placeholderText}
            style={inputStyles}
            {disabled} />
    </div>

    <div class="indicators">
        {#if loading}
            <div class="icon loading" aria-hidden="true">
                <slot name="loading-icon">
                    <LoadingIcon />
                </slot>
            </div>
        {/if}

        {#if showClear}
            <div
                class="icon clear-select"
                on:click|preventDefault|stopPropagation={handleClear}
                on:pointerdown|preventDefault|stopPropagation
                aria-hidden="true">
                <slot name="clear-icon">
                    <ClearIcon />
                </slot>
            </div>
        {/if}

        {#if showChevron}
            <div class="icon chevron" aria-hidden="true">
                <slot name="chevron-icon" {listOpen}>
                    <ChevronIcon />
                </slot>
            </div>
        {/if}
    </div>

    {#if !multiple || (multiple && !showMultiSelect)}
        <input name={inputAttributes.name} type="hidden" value={value ? value[itemId] : null} />
    {/if}

    {#if multiple && showMultiSelect}
        {#each value as item}
            <input name={inputAttributes.name} type="hidden" value={item ? item[itemId] : null} />
        {/each}
    {/if}
</div>

<style>
    .svelte-select {
        /* deprecating camelCase custom props in favour of kebab-case for v5 */
        --borderRadius: var(--border-radius);
        --clearSelectColor: var(--clear-select-color);
        --clearSelectWidth: var(--clear-select-width);
        --disabledBackground: var(--disabled-background);
        --disabledBorderColor: var(--disabled-border-color);
        --disabledColor: var(--disabled-color);
        --disabledPlaceholderColor: var(--disabled-placeholder-color);
        --disabledPlaceholderOpacity: var(--disabled-placeholder-opacity);
        --errorBackground: var(--error-background);
        --errorBorder: var(--error-border);
        --groupItemPaddingLeft: var(--group-item-padding-left);
        --groupTitleColor: var(--group-title-color);
        --groupTitleFontSize: var(--group-title-font-size);
        --groupTitleFontWeight: var(--group-title-font-weight);
        --groupTitlePadding: var(--group-title-padding);
        --groupTitleTextTransform: var(--group-title-text-transform);
        --indicatorColor: var(--chevron-color);
        --indicatorHeight: var(--chevron-height);
        --indicatorWidth: var(--chevron-width);
        --inputColor: var(--input-color);
        --inputFontSize: var(--input-font-size);
        --inputLeft: var(--input-left);
        --inputLetterSpacing: var(--input-letter-spacing);
        --inputMargin: var(--input-margin);
        --inputPadding: var(--input-padding);
        --itemActiveBackground: var(--item-active-background);
        --itemColor: var(--item-color);
        --itemFirstBorderRadius: var(--item-first-border-radius);
        --itemHoverBG: var(--item-hover-bg);
        --itemHoverColor: var(--item-hover-color);
        --itemIsActiveBG: var(--item-is-active-bg);
        --itemIsActiveColor: var(--item-is-active-color);
        --itemIsNotSelectableColor: var(--item-is-not-selectable-color);
        --itemPadding: var(--item-padding);
        --listBackground: var(--list-background);
        --listBorder: var(--list-border);
        --listBorderRadius: var(--list-border-radius);
        --listEmptyColor: var(--list-empty-color);
        --listEmptyPadding: var(--list-empty-padding);
        --listEmptyTextAlign: var(--list-empty-text-align);
        --listMaxHeight: var(--list-max-height);
        --listPosition: var(--list-position);
        --listShadow: var(--list-shadow);
        --listZIndex: var(--list-z-index);
        --multiItemBG: var(--multi-item-bg);
        --multiItemBorderRadius: var(--multi-item-border-radius);
        --multiItemDisabledHoverBg: var(--multi-item-disabled-hover-bg);
        --multiItemDisabledHoverColor: var(--multi-item-disabled-hover-color);
        --multiItemHeight: var(--multi-item-height);
        --multiItemMargin: var(--multi-item-margin);
        --multiItemPadding: var(--multi-item-padding);
        --multiSelectInputMargin: var(--multi-select-input-margin);
        --multiSelectInputPadding: var(--multi-select-input-padding);
        --multiSelectPadding: var(--multi-select-padding);
        --placeholderColor: var(--placeholder-color);
        --placeholderOpacity: var(--placeholder-opacity);
        --selectedItemPadding: var(--selected-item-padding);
        --spinnerColor: var(--spinner-color);
        --spinnerHeight: var(--spinner-height);
        --spinnerWidth: var(--spinner-width);

        --internal-padding: 0 0 0 16px;
        --height: 42px;
        border: var(--border, 1px solid #d8dbdf);
        border-radius: var(--border-radius, 6px);
        min-height: var(--height, 42px);
        position: relative;
        display: flex;
        align-items: center;
        padding: var(--padding, var(--internal-padding));
        background: var(--background, #fff);
        margin: var(--margin, 0);
        width: var(--width, 100%);
        font-size: var(--font-size, 14px);
    }

    * {
        box-sizing: var(--box-sizing, border-box);
    }

    .svelte-select:hover,
    .svelte-select:hover .chevron {
        border: var(--border-hover, 1px solid #b2b8bf);
    }

    .value-container {
        display: flex;
        flex: 1 1 0%;
        flex-wrap: wrap;
        align-items: center;
        gap: 5px 10px;
        padding: 5px 0;
        position: relative;
        overflow: hidden;
        align-self: stretch;
    }

    .indicators {
        display: flex;
        flex-shrink: 0;
    }

    input {
        position: absolute;
        cursor: default;
        border: none;
        color: var(--input-color, var(--item-color));
        padding: var(--input-padding, 0);
        letter-spacing: var(--input-letter-spacing, inherit);
        margin: var(--input-margin, 0);
        min-width: 10px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background: transparent;
        font-size: var(--font-size);
    }

    input::placeholder {
        color: var(--placeholder-color, #78848f);
        opacity: var(--placeholder-opacity, 1);
    }

    input:focus {
        outline: none;
    }

    .svelte-select.focused,
    .svelte-select.focused .chevron {
        border: var(--border-focused, 1px solid #006fe8);
    }

    .disabled {
        background: var(--disabled-background, #ebedef);
        border-color: var(--disabled-border-color, #ebedef);
        color: var(--disabled-color, #c1c6cc);
    }

    .disabled input::placeholder {
        color: var(--disabled-placeholder-color, #c1c6cc);
        opacity: var(--disabled-placeholder-opacity, 1);
    }

    .selected-item {
        position: relative;
        overflow-x: hidden;
        padding: var(--selected-item-padding, 0 20px 0 0);
        text-overflow: ellipsis;
        white-space: nowrap;
        color: var(--selected-item-color, inherit);
        font-size: var(--font-size);
    }

    .multi .selected-item {
        position: absolute;
        line-height: var(--height);
        height: var(--height);
    }

    .selected-item:focus {
        outline: none;
    }

    .hide-selected-item {
        opacity: 0;
    }

    .icon {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .clear-select {
        width: var(--clear-select-width, 40px);
        height: var(--clear-select-height, 40px);
        color: var(--clear-select-color, var(--icons-color));
        margin: var(--clear-select-margin, 0);
        pointer-events: all;
        flex-shrink: 0;
    }

    .loading {
        width: var(--loading-width, 40px);
        height: var(--loading-height, 40px);
        color: var(--loading-color, var(--icons-color));
        margin: var(--loading--margin, 0);
        flex-shrink: 0;
    }

    .chevron {
        width: var(--chevron-width, 40px);
        height: var(--chevron-height, 40px);
        background: var(--chevron-background, transparent);
        pointer-events: var(--chevron-pointer-events, none);
        color: var(--chevron-color, var(--icons-color));
        border: var(--chevron-border, 0 0 0 1px solid #d8dbdf);
        flex-shrink: 0;
    }

    .multi {
        padding: var(--multi-select-padding, var(--internal-padding));
    }

    .multi input {
        padding: var(--multi-select-input-padding, 0);
        position: relative;
        margin: var(--multi-select-input-margin, 5px 0);
        flex: 1 1 40px;
    }

    .error {
        border: var(--error-border, 1px solid #ff2d55);
        background: var(--error-background, #fff);
    }

    .a11y-text {
        z-index: 9999;
        border: 0px;
        clip: rect(1px, 1px, 1px, 1px);
        height: 1px;
        width: 1px;
        position: absolute;
        overflow: hidden;
        padding: 0px;
        white-space: nowrap;
    }

    .multi-item {
        background: var(--multi-item-bg, #ebedef);
        margin: var(--multi-item-margin, 0);
        outline: var(--multi-item-outline, 1px solid #ddd);
        border-radius: var(--multi-item-border-radius, 4px);
        height: var(--multi-item-height, 25px);
        line-height: var(--multi-item-height, 25px);
        display: flex;
        cursor: default;
        padding: var(--multi-item-padding, 0 5px);
        overflow: hidden;
        gap: var(--multi-item-gap, 4px);
        outline-offset: -1px;
        max-width: var(--multi-max-width, none);
        color: var(--multi-item-color, var(--item-color));
    }

    .multi-item.disabled:hover {
        background: var(--multi-item-disabled-hover-bg, #ebedef);
        color: var(--multi-item-disabled-hover-color, #c1c6cc);
    }

    .multi-item-text {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .multi-item-clear {
        display: flex;
        align-items: center;
        justify-content: center;
        --clear-icon-color: var(--multi-item-clear-icon-color, #000);
    }

    .multi-item.active {
        outline: var(--multi-item-active-outline, 1px solid #006fe8);
    }

    .svelte-select-list {
        box-shadow: var(--list-shadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));
        border-radius: var(--list-border-radius, 4px);
        max-height: var(--list-max-height, 252px);
        overflow-y: auto;
        background: var(--list-background, #fff);
        position: var(--list-position, absolute);
        z-index: var(--list-z-index, 2);
        border: var(--list-border);
    }

    .list-group-title {
        color: var(--group-title-color, #8f8f8f);
        cursor: default;
        font-size: var(--group-title-font-size, 12px);
        font-weight: var(--group-title-font-weight, 600);
        height: var(--height);
        line-height: var(--height);
        padding: var(--group-title-padding, 0 20px);
        text-overflow: ellipsis;
        overflow-x: hidden;
        white-space: nowrap;
        text-transform: var(--group-title-text-transform, uppercase);
    }

    .empty {
        text-align: var(--list-empty-text-align, center);
        padding: var(--list-empty-padding, 20px 0);
        color: var(--list-empty-color, #78848f);
    }

    .item {
        cursor: default;
        height: var(--item-height, var(--height));
        line-height: var(--item-line-height, var(--height));
        padding: var(--item-padding, 0 20px);
        color: var(--item-color, inherit);
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        width: 100%;
    }

    .item.group-item {
        padding-left: var(--group-item-padding-left, 40px);
    }

    .item:active {
        background: var(--item-active-background, #b9daff);
    }

    .item.active {
        background: var(--item-is-active-bg, #007aff);
        color: var(--item-is-active-color, #fff);
    }

    .item.not-selectable {
        color: var(--item-is-not-selectable-color, #999);
    }

    .item.first {
        border-radius: var(--item-first-border-radius, 4px 4px 0 0);
    }

    .item.hover:not(.active) {
        background: var(--item-hover-bg, #e7f2ff);
        color: var(--item-hover-color, inherit);
    }
</style>
