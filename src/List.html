<svelte:window on:keydown="handleKeyDown(event)"/>

<div class="listContainer" ref:container>
  {#each items as item, i}
  {#if item.groupValue}
  <div class="listGroupTitle">
    {item.groupValue}
  </div>
  {/if}

  <div on:mouseover="handleHover(i)" on:click="handleClick(item, i, event)"
       class="listItem {itemClasses(hoverItemIndex, item, i, items, selectedItem, optionIdentifier)}">
    <svelte:component this="{Item}" {item} {getOptionLabel}/>
  </div>
  {:else}
  <div class="empty">{noOptionsMessage}</div>
  {/each}
</div>

<style>
  .listContainer {
    box-shadow: 0 2px 3px 0 rgba(44, 62, 80, 0.24);
    border-radius: 4px;
    max-height: 250px;
    overflow-y: auto;
    background: #fff;
  }

  .listGroupTitle {
    color: #8f8f8f;
    cursor: default;
    font-size: 12px;
    height: 40px;
    line-height: 40px;
    padding: 0 20px;
    text-overflow: ellipsis;
    overflow-x: hidden;
    white-space: nowrap;
    text-transform: uppercase;
  }

  .listItem {
    cursor: default;
    height: 40px;
    line-height: 40px;
    padding: 0 20px;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
  }

  .listItem.hover {
    background: #e7f2ff;
  }

  .listItem:active {
    background: #b9daff;
  }

  .listItem:first-child {
    border-radius: 4px 4px 0 0;
  }

  .listItem.active {
    background: #007aff;
    color: #fff;
  }

  .empty {
    text-align: center;
    padding: 20px 0;
    color: #78848F;
  }
</style>

<script>
  import Item from './Item.html';

  export default {
    data() {
      return {
        hoverItemIndex: 0,
        optionIdentifier: 'value',
        items: [],
        Item,
        selectedItem: undefined,
        getOptionLabel: (option) => option.label
      }
    },
    onupdate({changed, current}) {
      if (changed.items && current.items.length > 0) {
        if (!current.items[current.hoverItemIndex]) {
          this.set({
            hoverItemIndex: current.items.length - 1
          });
        }
      }
      if (changed.activeItemIndex && current.activeItemIndex > -1) {
        this.set({
          hoverItemIndex: current.activeItemIndex,
        });

        this.scrollToActiveItem('active');
      }
      if (changed.selectedItem && current.selectedItem) {
        this.scrollToActiveItem('active');
        if (current.items) {
          const hoverItemIndex = current.items.findIndex((item) => item.value === current.selectedItem.value);

          if (hoverItemIndex) {
            this.set({hoverItemIndex});
          }
        }
      }
    },
    helpers: {
      itemClasses(hoverItemIndex, item, itemIndex, items, selectedItem, optionIdentifier) {
        return `${selectedItem && (selectedItem[optionIdentifier] === item[optionIdentifier]) ? 'active ' : ''}${hoverItemIndex === itemIndex || items.length === 1 ? 'hover' : ''}`;
      }
    },
    methods: {
      handleSelect(item) {
        this.fire('itemSelected', item);
      },
      handleHover(i) {
        this.set({hoverItemIndex: i});
      },
      handleClick(item, i, event) {
        event.stopPropagation();
        this.set({activeItemIndex: i, hoverItemIndex: i});
        this.handleSelect(item);
      },
      updateHoverItem(increment) {
        let {items, hoverItemIndex} = this.get();

        if (increment > 0 && hoverItemIndex === (items.length - 1)) {
          hoverItemIndex = 0;
        }
        else if (increment < 0 && hoverItemIndex === 0) {
          hoverItemIndex = items.length - 1;
        }
        else {
          hoverItemIndex = hoverItemIndex + increment;
        }

        this.set({hoverItemIndex});
        this.scrollToActiveItem('hover');
      },
      handleKeyDown(e) {
        const {items, hoverItemIndex} = this.get();

        switch (e.key) {
          case 'ArrowDown':
            e.preventDefault();
            items.length && this.updateHoverItem(1);
            break;
          case 'ArrowUp':
            e.preventDefault();
            items.length && this.updateHoverItem(-1);
            break;
          case 'Enter':
            e.preventDefault();
            this.set({activeItemIndex: hoverItemIndex});
            this.handleSelect(items[hoverItemIndex]);
            break;
          case 'Tab':
            e.preventDefault();
            this.set({activeItemIndex: hoverItemIndex});
            this.handleSelect(items[hoverItemIndex]);
            break;
        }
      },
      scrollToActiveItem(className) {
        const {container} = this.refs;
        let offsetBounding;
        const focusedElemBounding = container.querySelector(`.listItem.${className}`);

        if (focusedElemBounding) {
          offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
        }

        container.scrollTop -= offsetBounding;
      }
    }
  }
</script>
